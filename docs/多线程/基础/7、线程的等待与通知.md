### 1、线程的等待

#### 1.1、wait()函数

- 当一个线程调用一个**共享变量** 的wait的方法，该调用线程就会被阻塞挂起，知道被得到通知或被打断。
  -  1、其他线程调用该**共享变量**的notify方法或notifyAll方法；
  - 2、其他线程调用了该线程的interrupt方法，该线程抛出InterruptedException异常返回。
- 调用wait方法之前，没有事先获取该对象的**监视器锁**，则调用wait方法时调用线程会抛出IllegalMonitorStateException异常。

##### 1.1、监视器锁

1、执行synchronized同步代码块时，使用该共享变量作为参数

``` java
synchronized(共享变量){
    
}
```

2、调用该共享变量的方法，并且该方法使用了synchronized修饰。

```java
synchronized void add(int a,int b){
    
}
```

##### 1.2、虚假唤醒

虚假唤醒：一个线程可以在没有得到通知或者被打断的情况下，从挂起状态变成可以运行状态。

需要不停的去测试该线程被唤醒的条件是否满足，不满足则继续等待。

```java
synchronized (obj){
    while(条件不满足){
        
    }
}
```

##### 1.3、共享变量的锁

- 当前线程调用共享变量的wait方法后只会释放当前共享变量上的锁，如果当前线程还持有其他共享变量的锁，则这些锁并不会被释放。

##### 1.4、InterruptedException异常

- 当一个线程调用共享变量的wait方法被阻塞挂起之后，如果其他线程中断了该线程，则该线程会抛出InterruptedException异常并返回。

##### 1.5、wait(long timeout)函数

- 当超过指定timeout时间，即使没有被其他线程通知或打断，任然会从挂起状态变成可运行状态。

##### 1.6、wait(long timeout,int nanos)函数

- nanos>0才会使得timeout递增1。（没懂这个有什么用）

#### 2、线程通知

#### 2.1、notify()函数

- 一个线程调用**共享对象** 的notify()方法后，会唤醒一个在该共享变量上调用wait()方法后被挂起的线程，一个共享变量上可能有多个线程在等待，具体唤醒哪一个等待的线程是**随机**的。
- 被唤醒的线程不能马上从wait()方法返回并继续执行，它必须在获取了共享对象的监视器锁后才可以返回，也就是唤醒它的线程释放了共享变量上的监视器锁后，被唤醒的线程也不一定会获取到共享对象的监视器锁，这是因为该线程还需要跟其他线程一起竞争该锁，只有该线程竞争到了共享变量的监视器锁后才可以继续执行。

#### 2.2、notifyAll()函数

- 唤醒所有在该共享变量上由于调用了wait()方法而被挂起的线程。
- 在共享变量上调用notifyAll()方法只会唤醒调用这个方法前调用了wait系列函数而被放入共享变量等待集合里面的线程。如果调用了notifyAll()方法后一个线程在调用了该共享变量的wait系列的方法而放入阻塞集合中，该线程并不会被唤醒。