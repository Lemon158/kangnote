### 1、Redis设置过期时间

- Redis中有个设置时间过期的功能，即对存储在 redis 数据库中的值可以设置一个过期时间。作为一个缓存数据库，这是非常实用的。如我们一般项目中的 token 或者一些登录信息，尤其是短信验证码都是有时间限制的，按照传统的数据库处理方式，一般都是自己判断过期，这样无疑会严重影响项目性能。
- 我们 set key 的时候，都可以给一个 expire time，就是过期时间，通过过期时间我们可以指定这个 key 可以存活的时间

#### 1.1、常用命令

> timestamp表示时间戳

- `expire key ttl`：将 `key` 值的过期时间设置为 `ttl` **秒**。
- `pexpire key ttl`：将 `key` 值的过期时间设置为 `ttl` **毫秒**。
- `expireat key timestamp`：将 `key` 值的过期时间设置为指定的 `timestamp` **秒数**。
- `pexpireat key timestamp`：将 `key` 值的过期时间设置为指定的 `timestamp` **毫秒数**

----

- `ttl key` 返回 `key` 剩余过期秒数。
- `pttl key` 返回 `key` 剩余过期的毫秒数。



### 2、内存



### 3、删除策略

#### 3.1、立即删除（Redis当中不存在这种）

- 立即删除能保证内存中数据的最大新鲜度，因为它保证过期键值会在过期后马上被删除，其所占用的内存也会随之释放。但是立即删除对cpu是最不友好的。因为删除操作会占用cpu的时间，如果刚好碰上了cpu很忙的时候，比如正在做交集或排序等计算的时候，就会给cpu造成额外的压力，这会产生大量的性能消耗，同时也会影响数据的读取操作。
- 对CPU不友好，用处理器性能换区存储空间（时间换空间）

#### 3.2、惰性删除

- 数据到达过期时间，不做处理。等下次访问该数据时，如果未过期，返回数据；发现已过期，删除，返回不存在。
- 对内存是很不友好的，因为可能存在一些数据永远也不会被删除(除非用户手动执行FLUSHDB)

- 甚至可以将这种情况看作是一种内存泄漏–无用的垃圾数据占用了大量的内存，而服务器却不会自己去释放它们，这对于运行状态非常依赖于内存的Redis服务器来说,肯定不是一个好消息
- 对memory（内存）不友好，用存储空间换取处理器性能（拿空间换时间）

#### 3.3、定期删除

> 上述两种策略的折中

- 定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作的执行时长和频率来减少删除操作对CPU时间的影响
- Redis默认是每隔 100ms 就**随机抽取**一些设置了过期时间的key，检查其是否过期，如果过期就删除。

---

> 周期性轮询redis库中的时效性数据，采用随机抽取的策略，利用过期数据占比的方式控制删除频度

- CPU性能占用设置有峰值，检测频度可自定义设置
- 内存压力不是很大，长期占用内存的冷数据会被持续清理
- 期性抽查存储空间（随机抽查，重点抽查)

##### 3.3.1、存在的问题

- 定期删除策略的难点是确定删除操作执行的时长和频率：如果删除操作执行得太频繁，或者执行的时间太长，定期删除策略就会退化成定时删除策略，以至于将CPU时间过多地消耗在删除过期键上面。如果删除操作执行得太少，或者执行的时间太短，定期删除策略又会和惰性删除束略一样，出现浪费内存的情况。因此，如果采用定期删除策略的话，服务器必须根据情况，合理地设置删除操作的执行时长和执行频率。
- 有些键任然是删除不了，还是会导致内存耗尽

#### 3.4、总结

定期删除和惰性删除策略天然的互补，结合起来之后，定时删除策略就发生了一些改变，不在是每次扫描全部的 key 了，而是随机抽取一部分 key 进行检查，这样就降低了对 CPU 资源的损耗，惰性删除策略互补了为检查到的key，基本上满足了所有要求。但是有时候就是那么的巧，既没有被定时器抽取到，又没有被使用，这些数据又如何从内存中消失？没关系，还有内存淘汰机制，当内存不够用时，内存淘汰机制就会上场

- `Redis` 的定期扫描只会扫描设置了过期时间的键，因为设置了过期时间的键 `Redis` 会单独存储，所以不会出现扫描所有键的情况

### 4、Redis改进后的LRU算法

> `LRU` 全称为：`Least Recently Used`。即：最近最长时间未被使用(最近最少使用)。这个主要针对的是使用时间。

#### 4.1、传统LRU存在的问题

