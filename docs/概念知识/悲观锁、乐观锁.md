### 1、悲观锁

​	悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block（阻塞）直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。

​	例如，Java里面的同步原语`synchronized`关键字的实现也是悲观锁，`mysql`数据库中的`for update`语法。

#### 1.1、存在问题

- 在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。

- 一个线程持有锁会导致其它所有需要此锁的线程挂起。

- 如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。

### 2、乐观锁

​	乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，

​	乐观锁策略:提交版本必须大于记录当前版本才能执行更新

​	乐观锁的概念中其实已经阐述了它的具体实现细节：主要就是两个步骤：**冲突检测和数据更新。**其实现方式有一种比较典型的就是 Compare and Swap ( CAS )。

#### 2.1、CAS

https://www.cnblogs.com/raichen/p/7502241.html